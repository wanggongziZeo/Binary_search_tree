# 二叉搜索树
* 二叉搜索树是一种结合了折半搜索策略的连接结构。树中的每一个节点都包含一个项目和两个指向其他节点（子节点，child node）的指针。  

* 这种构思是每一个系欸但都有两个子节点，左节点和右节点。顺序按如下规则确定：在左节点中的项目是父节点中项目的前序项，而在右节点中的项目是父节点中项目的后续项。

* 二叉搜索树中的每一个节点本身是其后代节点的根，此节点与其后代节点构成一个子树。

* 二叉搜索树在链表结构中这和了折半搜索的效率。编程的代价是构造一棵树比创建一个链表更复杂。

## 二叉树ADT
很多操作与列表的操作相同，不同之处在于数据的层次性安排。  
* 类型属性：  
    1. 二叉树或者是一个空的节点集合（空树），或者是一个制定某一结点为根的节点集合；  
    2. 每个节点有两个作为其后代的树，称为左子数和右子树；  
    3. 每一个子树本身是一个二叉树，也包含它是个空树的可能性；  
    4. 二叉搜索树是有序的二叉树，它的每个节点包含一个项目，它的所有左子树的项目排在根项目的前面，而根项目排在所有右子树项目的前面。

* 操作类型：  
    1. 把树初始化为空树；
    2. 确定数是否为空；
    3. 确定树是否已满；
    4. 确定树中项目的个数；
    5. 向树中添加一个项目；
    6. 从树中删除一个项目；
    7. 在树中搜索一个项目；
    8. 访问树的每一个项目；
    9. 清空树。

## 二叉搜索树的接口  
    可以用多种方法实现二叉搜索树，甚至可以通过索引来用数组实现。但实现二叉搜索树最直接的方法是用指针链接动态分配的节点。

## 向树中添加项目
    向一个树中添加项目时，首先应该检查该树中是否还有空位给新节点。然后又由于二叉树被定义为不含有相同的项目，应该检查该树中是否有该项目。如果通过前两步，就可以创建一个新节点，将项目复制到此节点中，并设置此节点的左右指针为NULL。然后更新Tree结构的size成员，以记录添加一个新项目。接下来，要找出该把此节点放在树中什么位置。如果树为空，就要将根节点指针指向该新节点。否则，在树中查找到放置该新节点的位置。AddItem函数按照这条思路实现，并将其中的一些工作交给几个函数：SeekItem()、MakeNode()和AddNode().

    DeleteItem()函数还有另外一个请求：需要知道被删除项目的父节点，以便子节点被删除是父节点指向该自接待你的指针可以得到更新。因此将SeekItem()设计成返回包含两个指针的结构，其中一个指针指向包含该项目的节点（如果没找到该项目据返回NULL），另一个只想父节点（如果该节点为根节点，也即没有父节点，也返回NULL）。

    使用while循环来控制树中从上到下的搜索。SeekItem()使用ToLeft()和ToRight()在树中导航。开始时SeekItem()设置look.child指针指向树的根节点，然后沿着目标应在的路径重置look.child到后续的子树。同时，look.parent指向他的父节点。如果未找到匹配项目,look.child为NULL。如果匹配项目在根节点，look.parent为NULL。

    由于SeekItem()函数返回一个结构，所以它能和结构成员运算符一起使用，编写InTree()公用接口函数是很简单的。

## AddNode()函数
    AddNode()函数在二叉树搜索树包中是很难的函数。它要判断新节点去想何方，并添加之。具体的，它需要比较新项目和根项目来决定新项目要添加到左子树还是右子树。如果新项目是一个数字，可以使用 < 或者 > 进行比较。如果项目是一个字符串，可以使用strcmp()进行比较。但本例中的项目是包含两个字符串的结构，所以必须定义执行比较的函数。后面定义的ToLeft()当新项目应在左子树时返回true，而ToRight()函数当新项目应在右子树时返回true。这两个函数相当于 < 和 >，假设新项目要到左子树中去，左子树可能是空的。在这种情况下，AddNode()函数只用把左子指针指向新节点。但是如果左子树非空呢？则此函数就应该比较新项目和左子节点的项目，以决定新项目应到此子节点的左子树，还是右子树中去。

    这一过程继续进行，直到函数达到一个空的子树，在那一点添加新节点。递归是一种实现这种搜索的方法。即，在子节点而非根节点应用AddNode()函数。当左子树或右子树为空，即当root->left或root->right为NULL时函数的递归调用序列结束。切记root为只想当前子树顶部的指针，所以每次递归调用使它指向一个新的下一级子树。

## 删除项目
    删除一个项目是最难的，因为要将剩下的子树重新连接起来，以形成一个完成的树。重要的问题是需要做什么。  

    最简单情况，要删除的节点没有子节点，这种节点被称为叶节点（leaf）。在这种那个情况下，我们要做的就是将父节点的相应指针置为NULL，并用free()释放掉被删节点占用的内存。

    删除有一个子节点的节点就复杂些了。删除该节点使其子节点子树与树的其他部分分离开了。为修复这种情况，需要把字节点子树的地址存储在先前被删节点的地址在父亲节点中占据的位置。

## 删除节点
可以将工作分为两个任务：  
1. 将一个特定的项目与待删节点联系起来；
2. 实际删除此节点。  

有一点需要注意的是，在所有的情况下都必须修改父节点的指针，这将导致两个重要的结论：
1. 程序要能表示待删节点的父节点；
2. 要修改指针，代码必须将该指针的地址传递给执行删除任务的函数。

要修改的指针本身是Node *类型，即指向Node类型的指针。因为函数参数是指针的地址，所以参数是Node **类型的。

## 删除项目
问题在于讲一个节点和一个特定的项目联系起来。这个可以用SeekItem()函数完成，返回一个结构，此结构包含一个指向父节点的指针和一个指向包含项目的节点的指针。这样就可以通过使用父节点指针获得相应地址传递给DeleteNode()函数。

首先把DeleteItem()函数的返回值赋给look结构变量。如果look.child等于NULL。表明查找失败，DeleteItem()函数退出，并返回false。如果找到该Item，函数处理三种情况：  
* look.parent的值为NULL意味着该项目在根节点中。在这种情况下不需要更新父节点，而是需要更新Tree结构中的根指针。因此，函数将该指针的地址传递给DeleteNode()函数。
* 程序判断待删节点是其父节点的左子节点还是右子节点，然后传递适当指针的地址。

## 遍历树
遍历树要比遍历链表复杂得多，因为每个节点有两个分支。这种分支特性使得分而治之的递归方法成为此问题的自然选择。在每个节点中，函数要做以下工作：  
* 处理节点的项目
* 处理左子树（递归调用）
* 处理右子树（递归调用）

可以将此过程分给两个函数来完成：Traverse()和InOrder()。注意InOrder()函数先处理左子树，然后处理项目，最后处理右子树。

## 清空树
清空树与遍历树的基本过程是一样的，即代码需要访问每个节点并用free()函数释放之。还需要重置Tree的结构成员以说明是空Tree。DeleteAll()函数负责处理Tree结构，并将释放内存的任务分配给DeleteAllNodes()。后者和InOrder()函数构造相同。它保存了指针值root->right，以使它在根节点被释放后仍可以使用。

## 树的思想
二叉搜索树有些缺点。例如，二叉搜索树只在满员（或者称为平衡）时效率最高。假设要存储随意输入的单词，树看上去就有可能比较枝繁叶茂。

避免串状树的方法之一是在创建树时多加注意。如果一棵树或者子树开始在一边或另一边变得不平衡，需要重新排列节点使之恢复平衡。与之类似，在删除操作之后重新排列树。

在需要一个允许包含相同项目的二叉搜索树时，例如要分析一些文本，跟踪每个单词在文本中出现的次数。一种方法是将Item定义成包含一个单词和一个数值的结构。第一次碰到一个单词的时候，将其添加到树中，将其数值置为1.下一次碰到同样的单词，程序找到包含此单词的节点，并递增其中的数值。  
另一种可能的变化，考虑该程序实例。该例子以名字和种类进行排序，所以能在一个节点包含Sam和cat，另一个节点包含Sam和dog，第三个节点包含Sam和goat。但不能有两只猫都叫Sam。解决这个问题的方法是只以名字来排序。但只做这种变化是不够的，它将只允许一个Sam，不管是什么种类的；还需要将Item定义成一个结构列表来代替单一的结构。Sally第一次出现的时候，程序将创建一个新的节点，并创建一个新的列表，然后将Sally和它的种类添加到列表中。下一次Sally出现时，程序将定位到同一节点，并把新的数据添加到列表中。